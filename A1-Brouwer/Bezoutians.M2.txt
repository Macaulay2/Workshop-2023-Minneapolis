-- Given an endomorphism of affine space f=(f1,...,fn) given as a list of polynomials, return the Bezoutian corresponding to the endomorphism
bezoutian = method()

bezoutian (List) := (Matrix) => (Endo) -> (
    --use ring ideal(Endo);
    if dim ideal(Endo) > 0  then (print "Error: morphism does not have isolated zeroes"; return Endo;);
    n := #Endo;
    kk := coefficientRing(ring(Endo#0));
    R := kk[X_1..Y_n]; -- Here need to initialize R as kk[X_1..Y_n,x_1..x_n]???? Can substitute and change ring simultaneously? 
    D := mutableMatrix id_(R^n);
    --inputVarsFromS := gens ring Endo#0;
    --inputVars := toList apply(0..(n-1), i-> sub(inputVarsFromS_i,R));
    --print class inputVars#0;
    for i from 0 to (n-1) do (
	for j from 0 to (n-1) do(
	    -- substitute the variables and divide by the X_i - Y_j
	    -- Need to find a way to combine two lists in the following way: eg. {1,2,3,4,5} and {a,b,c,d,e} go to {1=>a, 2=>b, etc.}
	    targetList1 := toList (Y_1..Y_j|X_(j+1)..X_n);
	    targetList2 := toList (Y_1..Y_(j+1)| X_(j+2)..X_n);
	   
	    D_(i,j)= ((map(R,S,targetList1))(Endo_i)-(map(R,S,targetList2))(Endo_i)))/(X_(j+1)-Y_(j+1));
	    -- (sub(sub(Endo_i, R), sublist1) - sub(sub(Endo_i,R), sublist2))--/(X_(j+1)-Y_(j+1));
	    -- use promote when defining D_(i,j)
	    --print sublist2; 
	    --print sublist2;
	    print targetList1;
	); 
    );
);

S = QQ[x_1, x_2];
e = {x_1, x_2};
bezoutian(e);
-- Given an endomorphism of an affine space f=(f1,...,fn) given given as a sequence, and a closed point p of the target, return the local Bezoutian
--localBezoutian = method()
