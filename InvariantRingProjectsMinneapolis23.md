# Invariant Ring Project Ideas (Minneapolis 23)

Link to the Google Drive mentioned a few times below https://drive.google.com/drive/folders/1HvltRLSA588_vF6ELm0muBBKowxnRkPF?usp=sharing

There is also an Invariants project on M2 GitHub Wiki which Federico wrote some time ago and has some overlap here but also mentions other things which you can contact Federico about (via Zulip or email f.galetto@csuohio.edu) 
https://github.com/Macaulay2/M2/wiki/Project%3A-Invariants 

Below I (Francesca Gandini) have collected ideas from different folks I have reached out to. Mistakes and/or confusing things are my fault only, but you can reach out to people mentioned in the different project ideas to get help (who will be possibly more effective than I can be!).

---
## Testing InvariantRing
A question came up during the exercises about how large of a finite group (even acting diagonally) can be currently handled. I do not know, this might be fun to explore! Also it is always good to keep testing the package for bugs (or features?) that can be removed or edited accordingly. Another low key thing to do is to read through the documentation, find typos and/or point out places where things are unclear, not explained well (or at all) so that we can do some good old copy-editing.

--- 

## Subring package
In collaboration with SAGBI bases group, Michael Burr and Ollie Clarke (available on Zulip) as point people. Ollie has already collected some examples of these functions in a file that I will ask him to share with you all. The idea is to develop a small package that contains useful functions to deal with subrings. Some examples:
* projection onto subring generated by subset of variables
* intersection of subrings
* presentation of a subring (might be already there with a different name)
* isSubring (look at cache?)
 
 As a possible extension/theoretical/philosophical matter, one should wonder what a subring object (in Macaulay2 called a "Type") should be. Should invariant rings be of a subring type? What information should be cached in a subring type?

--- 

## Sasha's functions
Sasha Pevzner (available on Zulip) has already written some neat methods that would be nice to add to the package, just might need interested folks to test them and/or generalize them. I uploaded a sample file she shared in the Google Drive. I have moved the combination of diagonal and non-diagonal action in a separate project idea mostly because I added Matt's remarks there. Finally, I think that the warning she mentions has been fixed in the most recent version of the package, but please someone check this! Here is what Sasha says.

See attached a .m2 file with some examples of how I have used the InvariantRing package in the past. I will also say what each one is below.
* Getting the polynomial ring on which your group acts as a module over the ring of invariants.
* Making a "transfer map" function - this is just the Reynolds operator without division by the order of G. 
    * If implementing something like this, it would be nice to still generate the group, but not check for field coefficients, because this map is useful when working over the integers.

* This is just a question about a warning that I get sometimes when computing invariants. 
* This is an example that Matt Mastroeni worked out for me that involves combining a diagonal action with a finite action. I think this would be useful to implement.
* A very primitive function for getting character values for diagonal actions.


---
## Combining abelian and finite groups actions
Sasha had posed the following question to Matt Mastroeni, who kindly shared his response and some iodeas on how to implement this. He will be available on Zulip and/or by email (mmastro@iastate.edu) to follow up on this. 

Q: Can the InvariantRing package compute an action of the Coxeter presentation <s,t | s^2 = t^k = 1, sts = t^{-1} > of a dihedral group acting on a polynomial ring k[x_1..x_n, y_1..y_n] where s acts by swapping the x's and y's (sx_i = y_i and sy_i = x_i), and t acts by scaling the x's by a primitive kth root of unity, and the y's by its inverse by using a combination of finiteAction for the action of s and diagonalAction for the action of t? 

A: Currently, there is no method that does this, but I (Matt) was able to cobble together some code that solved her problem.  (I'm including a copy of my response to Sasha below that outlines in code how this can be done for the dihedral group.) 

In general, I think the problem can be framed as follows:

Consider the action on a polynomial ring R of a finite group G that is the semidirect product of an abelian normal subgroup H with a subgroup K, where H acts diagonally.  Is it possible to compute the ring of invariants R^G in stages using the fact that R^G = (R^H)^K?

In terms of implementation, this is asking whether it is possible to create a method for finiteAction using "mixed" data:

finiteAction (Matrix, List, List, Ring) := FiniteGroupAction => (M, d, K, R) -> (code)

where M is the weight matrix and d is the list of cyclic factors for the action of the abelian group H, K is a list of matrices specifying the action of the subgroup K, and R is the polynomial ring they act on.  

In principle, the way to compute the ring of invariants for such data would be to: 

1. use diagonalAction to compute the ring of invariants R^H, 
2. present R^H as a quotient of a polynomial ring S, 
3. lift the action of K to S in such a way that the presentation map S -> R^H is equivariant, 
4. compute S^K using finiteAction, and
5. push down the generators of S^K along the presentation map to obtain the generating invariants for R^G

However, there are a few theoretical issues/caveats that would need to be pinned down before implementing this in general:

* We have to be working in the nonmodular case because I think step (5) requires the existence of the Reynolds operator to be valid.
* It is not entirely clear to me how to create error tests to check that G is a semidirect product of H and K from the data (M, d, K).
* It is not clear to me what the correct restriction is on the list of matrices K to ensure that K acts linearly on the generators of R^H, which is necessary for the lifting in step (3).
* At least in the dihedral case, it might be worth checking whether it is possible to achieve the same result by just hardcoding the two matrices for the action of s and t using the package Cyclotomic for the roots of unity, applying finiteAction, and checking whether computing the invariants this way is faster or slower than the strategy proposed above. 

Matt's code and explanation to help with Sasha's request:

Get the invariants of the cyclic group C = < t >.

```
loadPackage "InvariantRing"
S = QQ[x_1,x_2,y_1,y_2]
d = {3}
M = matrix{{1,1,2,2}} -- act by \zeta, \zeta, \zeta^{-1},\zeta^{-1} where \zeta is a primitive 3rd root of 1
C = diagonalAction(M,d,S)
R = invariantRing C
```
We can compute the invariants of the full dihedral group as the s-invariant elements of the ring R.  But here, things get a little complicated because the current implementation of the InvariantRing package is designed only to compute invariants of finite groups on polynomial rings.  So, we need to compute a presentation of the invariant ring R as a quotient of a polynomial ring R’ in which the variables all have degree 1.

```
I = definingIdeal R
R' = ring I
R' = (coefficientRing R')[R'_*]
I = sub(I, R')
f = map(S, R', invariants C)
```
Since R is a nice toric ring (generated by monomials as an algebra over QQ) and C is a normal subgroup of the dihedral group, the action of s on R will take one monomial generator of R to another, and so, we can lift the action of s on R to the polynomial ring R’ in a way that makes the homomorphism f: R’ -> R equivariant (that is, f(sh) = sf(h)).

```
B = matrix{{0,0,1,0},{0,0,0,1},{1,0,0,0},{0,1,0,0}}
B' = transpose matrix apply(gens R, m -> apply(gens R, m' -> (m'' :=  sub(m, (vars S)*(transpose B)); if m'' == m' then 1 else 0 ) )  )
refl = finiteAction({B'},R')
```
The invariants of the s-action on R’ should map surjectively onto the s-invariants of R so that we get a minimal set of generating invariants of the dihedral action as follows.
```
(ideal mingens ideal apply(invariants refl, h -> f h) )_*
```
Doing this for the above example produces the invariants:
```
{x_2*y_2, x_2*y_1+x_1*y_2, x_1*y_1, x_2^3+y_2^3, x_1*x_2^2+y_1*y_2^2, x_1^2*x_2+y_1^2*y_2, x_1^3+y_1^3}
```
---
## Diagonalising actions of abelian groups
In the exercises in the mini-school I posed the question

Q: Is there an overall strategy to finding a change of basis that makes any action of an abelian group diagonal? Can this be implemented in M2?

Turns out that someone whose name Francesca stupidly did not write down but she will eventually track down, knows how to do this and already has done checked this works for small examples! One caveat/possible obstacle is handing the fact that the eigenvalues of these matrices are roots of unity (so complex numbers which M2 dislikes). However this should be fixable with the package Cyclotomic as we only need to work in a (large enough) cyclotomic field.

I think this should connect to Sasha's function for computing the character values for diagonal actions. I do not know of methods in M2 for character values, so it would probably be nice to also have a function for this!

---
## Subspace arrangement approach
There is an algorithm to compute the Hilbert ideal using the vanishing ideal of a subspace arrangement of cardinality equal to the order of the group. I do not think this is currently implemented because generally it is slower than other methods for finte groups (allegedly? Maybe ). However, Francesca has proved that this approach also works for invariant skew polynomials in the exterior algebra. There are currently no methods to compute these, so it might be valuable to implement the approach in both settings! Trevor was particularly interested in this, here is what I (Francesca) told him when he asked about it!

Here is a minimal example for the regular action of ZZ/2. We have two subspaces for this action: the diagonal (corresponding to the action of the identity) and the ideal (y_1-x_2, y_2 -x_1) which corresponds to the generator of the group which permutes the basis elements. Now we can intersect these ideals and look at the image of the generators into the ring only in the x variables. These images will generate the Hilbert ideals and if they happen to be invariant, they also generate the invariant ring. You can run the same code with/without the SkewCommutative option and you will find higher degree invariants in the symmetric algebra which do not occur in the skew setting.

```
R = QQ[x_1..x_2, y_1..y_2, SkewCommutative=>true]

I1 = ideal(y_1 - x_1, y_2 - x_2)
I2 = ideal(y_1 - x_2, y_2 - x_1)

I=intersect(I1,I2)
R = ring I
S = QQ[x_1..x_2, SkewCommutative=>true]

f= map(S, R, {x_1, x_2, 0 , 0})
L= flatten entries gens I
L / f
```

---
## Other algorithms for invariants in exterior algebra?
The general question here is: which algorithms that we have implemented for polynomials work for skew polynomials (in the exterior algebra)?

In particular, I (Francesca) suspect that the diagonal action algorithm (at least for abelian groups but likely for tori too) should work in a skew setting. Working on this would require carefully reading the algorithm and proof of correctedness and determine whether this works over the exterior algebra, with possibly some adaptation. A write-up of the algorithm is my thesis, the precise pages are available in the Google drive linked in Zulip in the Mini-school:Invariant Rings substream.

---
## Skew commutative methods
As another offshoot of conversations about invariants in a skew settings (and as pointed out by Trevor in a GitHub issue), there are some things that work well in M2 with the option SkewCommutative=>true and some that do not. Here I record a few methods that would be nice to implement. Ollie might be interested in helping with this and Frank Moore has programmed a lot of non-commutative (nc) methods in M2. He can be pinged on Zulip or reached by email.

* kernel is currently not implemented for maps of rings with the skew commutative option. From a GitHub discussion Mahrud pointed out that graphIdeal of a RingMap might be what needs to be adapted (and if it could be adapted even to rings over the integers would make Sasha and Vic happy). On the other hand, Frank pointed out there is a way to compute the kernel using the AssociativeAlgebras package (which handles nc computations).  https://github.com/Macaulay2/M2/issues/2808
* a more exploratory project: what else does NOT work with skewcommutative option? Would be good to at least record, even if might not be able to fix right away.
* a theoretical project is to think about skewcommutative subalgebras of a skewcommutative algebra and ask what SAGBI theory would be like in this context. It is possible that things might be "too easy" to be interesting, but the SAGBI

---
## The Reynolds Operator for Semi-simple Groups
Work on this has been done by Dave Swinarski (dswinarski@fordham.edu) who has kindly shared code he wrote for Spin(10) and could be generalized to other semi-simple groups. Federico Galetto should also be interested in this and he can be reached remotely on Zulip (or by email f.galetto@csuohio.edu). Below is what Dave says. The files mentioned have been added to the Google Drive for the Invariant Ring project. 

Earlier this spring I posted a preprint on the arXiv related to Mukai's model of the moduli space of genus 7 curves. As part of that project, I wrote code in M2 to find and then evaluate an invariant polynomial for the action of Spin(10) on Wedge^7 S+, where S+ is the 16-dimensional half-spin representation of Spin(10). My strategy follows the ideas of Derksen and Kemper's book to construct the Reynolds operator [see Section 4.5.2 in Computational Invariant Theory] as repeated projections using the Casimir operator on the Lie algebra. Some of the code I wrote is specific to type D, but other parts are more general.

I met with Federico recently to discuss strategies for packaging this code in Macaulay2 code. He thought some of it might fit into a future version of InvariantRing, and suggested that I share it with you, since there is a group working on this at the workshop in Minnesota. If you'd like to chat over Zoom this weekend or next week, I'd be happy to do so. 

Here are several attachments. It's a lot, so I'll also give a brief description of each attachment.
* "2304.12936.pdf" is the arXiv preprint. It is mostly applications to algebraic geometry, but you can see how I finally computed an invariant for this high-dimensional representation.
* "InvariantsForSymdWedgekSpin2n.pdf" is some notes I wrote earlier this winter. With the approach described here, I was able to compute invariants for some smaller representations of the form Sym^d Wedge^k S+. But this approach wouldn't be able to handle the representation corresponding to Mukai's construction
* "LieAlgebraRepresentations.v2.3.m2" contains code for the following basic problem. Given a representation of a Lie algebra g -> gl(n), compute the corresponding action for Sym, Wedge, or Tensor products. 
* "SpinRepresentations.v1.7.m2" contains code for working with spin representations of so(2n). You can see here how I implemented so(2n) in order to compute the Casimir operator and Reynolds operator. It should be easy to implement types A-C in a similar way
* "so2n.v4.2.m2" contains the code used to produce the examples in InvariantsForSymdWedgekSpin2n.pdf.  This is where I actually compute the Casimir and Reynold operators
* "M2 transcript for InvariantsForSymdWedgekSpin2n.m2" is a transcript of several sessions where I compute the examples in the notes.

I apologize that all of my code is un- or under-documented. To be honest, I was never confident that I would be able to do the calculations required for Mukai's construction until they were actually complete. Now that they are, and I know what worked, I am trying to put things in a form that other people can use, too!

---

## Cayley’s Omega Process

For GLn and SLn there is an alternative method for computing the Reynolds operator. This is the so-called  ̋Cayley's Omega process, which was already known in the nineteenth century. This is described in Computational Invariant Theory by Derksen and Kemper Section 4.5.3. It would be nice to implement this! 

Coding this algorithm should not be too bad and in fact, I know that Derksen wrote this in Singular using C language several years ago... you can even find the C code searching through Singular if that would be helpful to you (Francesca did not find it particularly enlightening). 

---


## SAGBI bases for invariant rings
More cross-over with the cool folks of SAGBI bases! Stillman and Tsai have described how to use SAGBI bases to compute invariants. Ollie and I (Francesca) have wanted to think about this more and maybe see if it is worth implementing? It might be not very fast, but it could be useful as an alternative method to at least test (against) other computations! Here is the paper https://www.sciencedirect.com/science/article/pii/S0022404999000158 

---

## Specialized algorithms for elementary abelian groups 

A group of undergraduate students who I supervised worked on a neat algorithm for invariants of groups like (Z/p)^k (see https://github.com/lrizzolo/m2invariants). The algorithm idea has not been implemented fully because it requires first some "seed" invariants to start from. I think that if we can find in M2 a way to compute quickly a basis of the kernel of a matrix over a finite field of characteristic p, these elements can be used as seeds. I suspect that this method could be super quick if the linear algebra over FF_p is not an obstacle. There might be other interesting things in the students' repo, so feel free to explore! The students also gave a nice talk on their work, check out the video on YouTube
https://www.youtube.com/watch?v=BhZbL95cUHw